function [obj_list, x] = acceleratedDCA(A,b,sigma,x0,radius,norm_name,tol,rho,lambda_init,gama,xi)

% moi chi cai dat cho L_inf
if norm_name ~= "linf"
    error('invalid norm_name, this norm is not available for a moment.')
end

obj_list = [];
obj = objective(A,b,x0);
obj_list = [obj_list,obj];

time = [0];
acc_time = 0;

tic
I = eye(size(A));
x = x0;

lambda_bar = lambda_init;
count_success = 0;

while(1)
    y = (sigma*I-A)*x;
    z = -(b-y)/sigma;
    v = project(z,radius,norm_name);
    d = v - x;
    ns_d = norm(d)^2;
    
    if ns_d < tol^2
        break
    end
    
    D = (A*v+b)'*d/(sigma*ns_d);
    
    tmp1 = -(radius+v)./d;
    tmp2 = (radius-v)./d;
    
    alpha1 = max([tmp1(d>0);tmp2(d<0)]);
    alpha2 = min([tmp2(d>0);tmp1(d<0)]);
  
    if alpha1<= -D <= alpha2
        alpha = -D;
    elseif alpha1^2 + 2*D*alpha1 <= alpha2^2 + 2*D*alpha2
        alpha = alpha1;
    else
        alpha = alpha2;
    end
    
    if alpha >0
        % Armijo-type line-search
        lambda = lambda_bar;
        disp('Armijo-type line-search...')
        disp('lambda_bar')
        disp(lambda_bar)

        while objective(A,b,v+lambda*d) > objective(A,b,v)-(rho/2)*ns_d*lambda^2 ...
                || lambda > alpha2 || lambda < alpha1
            % decrease lambda
            lambda = gama*lambda;
        end
        
        if lambda == lambda_bar
            count_success = count_success + 1;
            if count_success == 2
                lambda_bar = xi*lambda_bar;
                count_success = 1;
                disp('two consecutive successful trials')
            end
        else
            lambda_bar = lambda;
            count_success = 0;
            disp('fail trail')
        end
        
    else
        lambda = alpha;
    end
    
    x = v + lambda*d; 
    
    % compute the objective
    obj = objective(A,b,x);
    obj_list = [obj_list,obj];
    
end
end